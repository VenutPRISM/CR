

Terminals which are not used:

   ILLEGAL


Conflict in state 63 between rule 33 and token PLUS resolved as reduce.
Conflict in state 63 between rule 33 and token MINUS resolved as reduce.
Conflict in state 63 between rule 33 and token MUL resolved as reduce.
Conflict in state 63 between rule 33 and token DIV resolved as reduce.
Conflict in state 63 between rule 33 and token MOD resolved as reduce.
Conflict in state 83 between rule 56 and token LOR resolved as reduce.
Conflict in state 83 between rule 56 and token LAND resolved as reduce.
Conflict in state 92 between rule 28 and token PLUS resolved as reduce.
Conflict in state 92 between rule 28 and token MINUS resolved as reduce.
Conflict in state 92 between rule 28 and token MUL resolved as shift.
Conflict in state 92 between rule 28 and token DIV resolved as shift.
Conflict in state 92 between rule 28 and token MOD resolved as shift.
Conflict in state 93 between rule 29 and token PLUS resolved as reduce.
Conflict in state 93 between rule 29 and token MINUS resolved as reduce.
Conflict in state 93 between rule 29 and token MUL resolved as shift.
Conflict in state 93 between rule 29 and token DIV resolved as shift.
Conflict in state 93 between rule 29 and token MOD resolved as shift.
Conflict in state 94 between rule 30 and token PLUS resolved as reduce.
Conflict in state 94 between rule 30 and token MINUS resolved as reduce.
Conflict in state 94 between rule 30 and token MUL resolved as reduce.
Conflict in state 94 between rule 30 and token DIV resolved as reduce.
Conflict in state 94 between rule 30 and token MOD resolved as reduce.
Conflict in state 95 between rule 31 and token PLUS resolved as reduce.
Conflict in state 95 between rule 31 and token MINUS resolved as reduce.
Conflict in state 95 between rule 31 and token MUL resolved as reduce.
Conflict in state 95 between rule 31 and token DIV resolved as reduce.
Conflict in state 95 between rule 31 and token MOD resolved as reduce.
Conflict in state 96 between rule 32 and token PLUS resolved as reduce.
Conflict in state 96 between rule 32 and token MINUS resolved as reduce.
Conflict in state 96 between rule 32 and token MUL resolved as reduce.
Conflict in state 96 between rule 32 and token DIV resolved as reduce.
Conflict in state 96 between rule 32 and token MOD resolved as reduce.
Conflict in state 111 between rule 54 and token LOR resolved as reduce.
Conflict in state 111 between rule 54 and token LAND resolved as shift.
Conflict in state 112 between rule 55 and token LOR resolved as reduce.
Conflict in state 112 between rule 55 and token LAND resolved as reduce.

Grammar
rule 1    program -> stms
rule 2    program -> stms END
rule 3    stms -> stm
rule 4    stms -> stms stm
rule 5    stm -> decl
rule 6    stm -> oper
rule 7    stm -> error SM
rule 8    stm -> error ENDIF
rule 9    stm -> error ENDWHILE
rule 10   decl -> type defs SM
rule 11   type -> TYPE
rule 12   defs -> def
rule 13   defs -> defs CM def
rule 14   def -> NAME
rule 15   def -> NAME LBR expr RBR
rule 16   oper -> assign
rule 17   oper -> if
rule 18   oper -> while
rule 19   oper -> BREAK SM
rule 20   oper -> CONTINUE SM
rule 21   oper -> input
rule 22   oper -> output
rule 23   oper -> outputln
rule 24   assign -> lval ASG expr SM
rule 25   lval -> lval_name
rule 26   lval -> lval_name LBR expr RBR
rule 27   lval_name -> NAME
rule 28   expr -> expr PLUS expr
rule 29   expr -> expr MINUS expr
rule 30   expr -> expr MUL expr
rule 31   expr -> expr DIV expr
rule 32   expr -> expr MOD expr
rule 33   expr -> MINUS expr
rule 34   expr -> NAME
rule 35   expr -> NAME LBR expr RBR
rule 36   expr -> INT_CONST
rule 37   expr -> DOUBLE_CONST
rule 38   expr -> STRING_CONST
rule 39   expr -> LPAR expr RPAR
rule 40   if -> ifh stms ENDIF
rule 41   @1 ->		/* empty */
rule 42   if -> ifh stms @1 else ENDIF
rule 43   @2 ->		/* empty */
rule 44   if -> ifh stms @2 elseifs ENDIF
rule 45   ifh -> IF LPAR lexpr RPAR
rule 46   elseifs -> elseiflist
rule 47   elseifs -> elseiflist else
rule 48   elseiflist -> elseif
rule 49   elseiflist -> elseiflist elseif
rule 50   else -> ELSE stms
rule 51   elseif -> elseifh stms
rule 52   elseifh -> ELSEIF LPAR lexpr RPAR
rule 53   lexpr -> expr RELOP expr
rule 54   lexpr -> lexpr LOR lexpr
rule 55   lexpr -> lexpr LAND lexpr
rule 56   lexpr -> LNOT lexpr
rule 57   lexpr -> LPAR lexpr RPAR
rule 58   while -> whileh stms ENDWHILE
rule 59   whileh -> WHILE LPAR lexpr RPAR
rule 60   input -> INPUT inputlst SM
rule 61   inputlst -> lval
rule 62   inputlst -> inputlst CM lval
rule 63   output -> OUTPUT outputlst SM
rule 64   outputln -> OUTPUTLN SM
rule 65   outputln -> OUTPUTLN outputlst SM
rule 66   outputlst -> expr
rule 67   outputlst -> outputlst CM expr

Terminals, with rules where they appear

$ (-1)
error (256) 7 8 9
NAME (258) 14 15 27 34 35
INT_CONST (259) 36
DOUBLE_CONST (260) 37
STRING_CONST (261) 38
WHILE (262) 59
ENDWHILE (263) 9 58
IF (264) 45
ENDIF (265) 8 40 42 44
ELSE (266) 50
ELSEIF (267) 52
TYPE (268) 11
BREAK (269) 19
CONTINUE (270) 20
SM (271) 7 10 19 20 24 60 63 64 65
CM (272) 13 62 67
LBR (273) 15 26 35
RBR (274) 15 26 35
LPAR (275) 39 45 52 57 59
RPAR (276) 39 45 52 57 59
ILLEGAL (277)
INPUT (278) 60
OUTPUT (279) 63
OUTPUTLN (280) 64 65
END (281) 2
ASG (282) 24
RELOP (283) 53
LOR (284) 54
LAND (285) 55
LNOT (286) 56
PLUS (287) 28
MINUS (288) 29 33
MUL (289) 30
DIV (290) 31
MOD (291) 32
UMINUS (292)

Nonterminals, with rules where they appear

program (38)
    on left: 1 2
stms (39)
    on left: 3 4, on right: 1 2 4 40 42 44 50 51 58
stm (40)
    on left: 5 6 7 8 9, on right: 3 4
decl (41)
    on left: 10, on right: 5
type (42)
    on left: 11, on right: 10
defs (43)
    on left: 12 13, on right: 10 13
def (44)
    on left: 14 15, on right: 12 13
oper (45)
    on left: 16 17 18 19 20 21 22 23, on right: 6
assign (46)
    on left: 24, on right: 16
lval (47)
    on left: 25 26, on right: 24 61 62
lval_name (48)
    on left: 27, on right: 25 26
expr (49)
    on left: 28 29 30 31 32 33 34 35 36 37 38 39, on right: 15 24 26
    28 29 30 31 32 33 35 39 53 66 67
if (50)
    on left: 40 42 44, on right: 17
@1 (51)
    on left: 41, on right: 42
@2 (52)
    on left: 43, on right: 44
ifh (53)
    on left: 45, on right: 40 42 44
elseifs (54)
    on left: 46 47, on right: 44
elseiflist (55)
    on left: 48 49, on right: 46 47 49
else (56)
    on left: 50, on right: 42 47
elseif (57)
    on left: 51, on right: 48 49
elseifh (58)
    on left: 52, on right: 51
lexpr (59)
    on left: 53 54 55 56 57, on right: 45 52 54 55 56 57 59
while (60)
    on left: 58, on right: 18
whileh (61)
    on left: 59, on right: 58
input (62)
    on left: 60, on right: 21
inputlst (63)
    on left: 61 62, on right: 60 62
output (64)
    on left: 63, on right: 22
outputln (65)
    on left: 64 65, on right: 23
outputlst (66)
    on left: 66 67, on right: 63 65 67


state 0

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    program	go to state 124
    stms	go to state 11
    stm 	go to state 12
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 1

    stm  ->  error . SM   (rule 7)
    stm  ->  error . ENDIF   (rule 8)
    stm  ->  error . ENDWHILE   (rule 9)

    ENDWHILE	shift, and go to state 26
    ENDIF	shift, and go to state 27
    SM  	shift, and go to state 28



state 2

    lval_name  ->  NAME .   (rule 27)

    $default	reduce using rule 27 (lval_name)



state 3

    whileh  ->  WHILE . LPAR lexpr RPAR   (rule 59)

    LPAR	shift, and go to state 29



state 4

    ifh  ->  IF . LPAR lexpr RPAR   (rule 45)

    LPAR	shift, and go to state 30



state 5

    type  ->  TYPE .   (rule 11)

    $default	reduce using rule 11 (type)



state 6

    oper  ->  BREAK . SM   (rule 19)

    SM  	shift, and go to state 31



state 7

    oper  ->  CONTINUE . SM   (rule 20)

    SM  	shift, and go to state 32



state 8

    input  ->  INPUT . inputlst SM   (rule 60)

    NAME	shift, and go to state 2

    lval	go to state 33
    lval_name	go to state 18
    inputlst	go to state 34



state 9

    output  ->  OUTPUT . outputlst SM   (rule 63)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 41
    outputlst	go to state 42



state 10

    outputln  ->  OUTPUTLN . SM   (rule 64)
    outputln  ->  OUTPUTLN . outputlst SM   (rule 65)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    SM  	shift, and go to state 43
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 41
    outputlst	go to state 44



state 11

    program  ->  stms .   (rule 1)
    program  ->  stms . END   (rule 2)
    stms  ->  stms . stm   (rule 4)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10
    END 	shift, and go to state 45

    $   	reduce using rule 1 (program)

    stm 	go to state 46
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 12

    stms  ->  stm .   (rule 3)

    $default	reduce using rule 3 (stms)



state 13

    stm  ->  decl .   (rule 5)

    $default	reduce using rule 5 (stm)



state 14

    decl  ->  type . defs SM   (rule 10)

    NAME	shift, and go to state 47

    defs	go to state 48
    def 	go to state 49



state 15

    stm  ->  oper .   (rule 6)

    $default	reduce using rule 6 (stm)



state 16

    oper  ->  assign .   (rule 16)

    $default	reduce using rule 16 (oper)



state 17

    assign  ->  lval . ASG expr SM   (rule 24)

    ASG 	shift, and go to state 50



state 18

    lval  ->  lval_name .   (rule 25)
    lval  ->  lval_name . LBR expr RBR   (rule 26)

    LBR 	shift, and go to state 51

    $default	reduce using rule 25 (lval)



state 19

    oper  ->  if .   (rule 17)

    $default	reduce using rule 17 (oper)



state 20

    if  ->  ifh . stms ENDIF   (rule 40)
    if  ->  ifh . stms @1 else ENDIF   (rule 42)
    if  ->  ifh . stms @2 elseifs ENDIF   (rule 44)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    stms	go to state 52
    stm 	go to state 12
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 21

    oper  ->  while .   (rule 18)

    $default	reduce using rule 18 (oper)



state 22

    while  ->  whileh . stms ENDWHILE   (rule 58)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    stms	go to state 53
    stm 	go to state 12
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 23

    oper  ->  input .   (rule 21)

    $default	reduce using rule 21 (oper)



state 24

    oper  ->  output .   (rule 22)

    $default	reduce using rule 22 (oper)



state 25

    oper  ->  outputln .   (rule 23)

    $default	reduce using rule 23 (oper)



state 26

    stm  ->  error ENDWHILE .   (rule 9)

    $default	reduce using rule 9 (stm)



state 27

    stm  ->  error ENDIF .   (rule 8)

    $default	reduce using rule 8 (stm)



state 28

    stm  ->  error SM .   (rule 7)

    $default	reduce using rule 7 (stm)



state 29

    whileh  ->  WHILE LPAR . lexpr RPAR   (rule 59)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 57



state 30

    ifh  ->  IF LPAR . lexpr RPAR   (rule 45)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 58



state 31

    oper  ->  BREAK SM .   (rule 19)

    $default	reduce using rule 19 (oper)



state 32

    oper  ->  CONTINUE SM .   (rule 20)

    $default	reduce using rule 20 (oper)



state 33

    inputlst  ->  lval .   (rule 61)

    $default	reduce using rule 61 (inputlst)



state 34

    input  ->  INPUT inputlst . SM   (rule 60)
    inputlst  ->  inputlst . CM lval   (rule 62)

    SM  	shift, and go to state 59
    CM  	shift, and go to state 60



state 35

    expr  ->  NAME .   (rule 34)
    expr  ->  NAME . LBR expr RBR   (rule 35)

    LBR 	shift, and go to state 61

    $default	reduce using rule 34 (expr)



state 36

    expr  ->  INT_CONST .   (rule 36)

    $default	reduce using rule 36 (expr)



state 37

    expr  ->  DOUBLE_CONST .   (rule 37)

    $default	reduce using rule 37 (expr)



state 38

    expr  ->  STRING_CONST .   (rule 38)

    $default	reduce using rule 38 (expr)



state 39

    expr  ->  LPAR . expr RPAR   (rule 39)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 62



state 40

    expr  ->  MINUS . expr   (rule 33)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 63



state 41

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    outputlst  ->  expr .   (rule 66)

    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68

    $default	reduce using rule 66 (outputlst)



state 42

    output  ->  OUTPUT outputlst . SM   (rule 63)
    outputlst  ->  outputlst . CM expr   (rule 67)

    SM  	shift, and go to state 69
    CM  	shift, and go to state 70



state 43

    outputln  ->  OUTPUTLN SM .   (rule 64)

    $default	reduce using rule 64 (outputln)



state 44

    outputln  ->  OUTPUTLN outputlst . SM   (rule 65)
    outputlst  ->  outputlst . CM expr   (rule 67)

    SM  	shift, and go to state 71
    CM  	shift, and go to state 70



state 45

    program  ->  stms END .   (rule 2)

    $default	reduce using rule 2 (program)



state 46

    stms  ->  stms stm .   (rule 4)

    $default	reduce using rule 4 (stms)



state 47

    def  ->  NAME .   (rule 14)
    def  ->  NAME . LBR expr RBR   (rule 15)

    LBR 	shift, and go to state 72

    $default	reduce using rule 14 (def)



state 48

    decl  ->  type defs . SM   (rule 10)
    defs  ->  defs . CM def   (rule 13)

    SM  	shift, and go to state 73
    CM  	shift, and go to state 74



state 49

    defs  ->  def .   (rule 12)

    $default	reduce using rule 12 (defs)



state 50

    assign  ->  lval ASG . expr SM   (rule 24)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 75



state 51

    lval  ->  lval_name LBR . expr RBR   (rule 26)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 76



state 52

    stms  ->  stms . stm   (rule 4)
    if  ->  ifh stms . ENDIF   (rule 40)
    if  ->  ifh stms . @1 else ENDIF   (rule 42)
    if  ->  ifh stms . @2 elseifs ENDIF   (rule 44)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    ENDIF	shift, and go to state 77
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    ELSE	reduce using rule 41 (@1)
    ELSEIF	reduce using rule 43 (@2)

    stm 	go to state 46
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    @1  	go to state 78
    @2  	go to state 79
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 53

    stms  ->  stms . stm   (rule 4)
    while  ->  whileh stms . ENDWHILE   (rule 58)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    ENDWHILE	shift, and go to state 80
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    stm 	go to state 46
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 54

    expr  ->  LPAR . expr RPAR   (rule 39)
    lexpr  ->  LPAR . lexpr RPAR   (rule 57)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 81
    lexpr	go to state 82



state 55

    lexpr  ->  LNOT . lexpr   (rule 56)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 83



state 56

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    lexpr  ->  expr . RELOP expr   (rule 53)

    RELOP	shift, and go to state 84
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 57

    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)
    whileh  ->  WHILE LPAR lexpr . RPAR   (rule 59)

    RPAR	shift, and go to state 85
    LOR 	shift, and go to state 86
    LAND	shift, and go to state 87



state 58

    ifh  ->  IF LPAR lexpr . RPAR   (rule 45)
    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)

    RPAR	shift, and go to state 88
    LOR 	shift, and go to state 86
    LAND	shift, and go to state 87



state 59

    input  ->  INPUT inputlst SM .   (rule 60)

    $default	reduce using rule 60 (input)



state 60

    inputlst  ->  inputlst CM . lval   (rule 62)

    NAME	shift, and go to state 2

    lval	go to state 89
    lval_name	go to state 18



state 61

    expr  ->  NAME LBR . expr RBR   (rule 35)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 90



state 62

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    expr  ->  LPAR expr . RPAR   (rule 39)

    RPAR	shift, and go to state 91
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 63

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    expr  ->  MINUS expr .   (rule 33)


    $default	reduce using rule 33 (expr)



state 64

    expr  ->  expr PLUS . expr   (rule 28)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 92



state 65

    expr  ->  expr MINUS . expr   (rule 29)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 93



state 66

    expr  ->  expr MUL . expr   (rule 30)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 94



state 67

    expr  ->  expr DIV . expr   (rule 31)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 95



state 68

    expr  ->  expr MOD . expr   (rule 32)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 96



state 69

    output  ->  OUTPUT outputlst SM .   (rule 63)

    $default	reduce using rule 63 (output)



state 70

    outputlst  ->  outputlst CM . expr   (rule 67)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 97



state 71

    outputln  ->  OUTPUTLN outputlst SM .   (rule 65)

    $default	reduce using rule 65 (outputln)



state 72

    def  ->  NAME LBR . expr RBR   (rule 15)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 98



state 73

    decl  ->  type defs SM .   (rule 10)

    $default	reduce using rule 10 (decl)



state 74

    defs  ->  defs CM . def   (rule 13)

    NAME	shift, and go to state 47

    def 	go to state 99



state 75

    assign  ->  lval ASG expr . SM   (rule 24)
    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)

    SM  	shift, and go to state 100
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 76

    lval  ->  lval_name LBR expr . RBR   (rule 26)
    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)

    RBR 	shift, and go to state 101
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 77

    if  ->  ifh stms ENDIF .   (rule 40)

    $default	reduce using rule 40 (if)



state 78

    if  ->  ifh stms @1 . else ENDIF   (rule 42)

    ELSE	shift, and go to state 102

    else	go to state 103



state 79

    if  ->  ifh stms @2 . elseifs ENDIF   (rule 44)

    ELSEIF	shift, and go to state 104

    elseifs	go to state 105
    elseiflist	go to state 106
    elseif	go to state 107
    elseifh	go to state 108



state 80

    while  ->  whileh stms ENDWHILE .   (rule 58)

    $default	reduce using rule 58 (while)



state 81

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    expr  ->  LPAR expr . RPAR   (rule 39)
    lexpr  ->  expr . RELOP expr   (rule 53)

    RPAR	shift, and go to state 91
    RELOP	shift, and go to state 84
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 82

    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)
    lexpr  ->  LPAR lexpr . RPAR   (rule 57)

    RPAR	shift, and go to state 109
    LOR 	shift, and go to state 86
    LAND	shift, and go to state 87



state 83

    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)
    lexpr  ->  LNOT lexpr .   (rule 56)


    $default	reduce using rule 56 (lexpr)



state 84

    lexpr  ->  expr RELOP . expr   (rule 53)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 39
    MINUS	shift, and go to state 40

    expr	go to state 110



state 85

    whileh  ->  WHILE LPAR lexpr RPAR .   (rule 59)

    $default	reduce using rule 59 (whileh)



state 86

    lexpr  ->  lexpr LOR . lexpr   (rule 54)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 111



state 87

    lexpr  ->  lexpr LAND . lexpr   (rule 55)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 112



state 88

    ifh  ->  IF LPAR lexpr RPAR .   (rule 45)

    $default	reduce using rule 45 (ifh)



state 89

    inputlst  ->  inputlst CM lval .   (rule 62)

    $default	reduce using rule 62 (inputlst)



state 90

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    expr  ->  NAME LBR expr . RBR   (rule 35)

    RBR 	shift, and go to state 113
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 91

    expr  ->  LPAR expr RPAR .   (rule 39)

    $default	reduce using rule 39 (expr)



state 92

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr PLUS expr .   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)

    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68

    $default	reduce using rule 28 (expr)



state 93

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr MINUS expr .   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)

    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68

    $default	reduce using rule 29 (expr)



state 94

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr MUL expr .   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)


    $default	reduce using rule 30 (expr)



state 95

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr DIV expr .   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)


    $default	reduce using rule 31 (expr)



state 96

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    expr  ->  expr MOD expr .   (rule 32)


    $default	reduce using rule 32 (expr)



state 97

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    outputlst  ->  outputlst CM expr .   (rule 67)

    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68

    $default	reduce using rule 67 (outputlst)



state 98

    def  ->  NAME LBR expr . RBR   (rule 15)
    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)

    RBR 	shift, and go to state 114
    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68



state 99

    defs  ->  defs CM def .   (rule 13)

    $default	reduce using rule 13 (defs)



state 100

    assign  ->  lval ASG expr SM .   (rule 24)

    $default	reduce using rule 24 (assign)



state 101

    lval  ->  lval_name LBR expr RBR .   (rule 26)

    $default	reduce using rule 26 (lval)



state 102

    else  ->  ELSE . stms   (rule 50)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    stms	go to state 115
    stm 	go to state 12
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 103

    if  ->  ifh stms @1 else . ENDIF   (rule 42)

    ENDIF	shift, and go to state 116



state 104

    elseifh  ->  ELSEIF . LPAR lexpr RPAR   (rule 52)

    LPAR	shift, and go to state 117



state 105

    if  ->  ifh stms @2 elseifs . ENDIF   (rule 44)

    ENDIF	shift, and go to state 118



state 106

    elseifs  ->  elseiflist .   (rule 46)
    elseifs  ->  elseiflist . else   (rule 47)
    elseiflist  ->  elseiflist . elseif   (rule 49)

    ELSE	shift, and go to state 102
    ELSEIF	shift, and go to state 104

    $default	reduce using rule 46 (elseifs)

    else	go to state 119
    elseif	go to state 120
    elseifh	go to state 108



state 107

    elseiflist  ->  elseif .   (rule 48)

    $default	reduce using rule 48 (elseiflist)



state 108

    elseif  ->  elseifh . stms   (rule 51)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    stms	go to state 121
    stm 	go to state 12
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 109

    lexpr  ->  LPAR lexpr RPAR .   (rule 57)

    $default	reduce using rule 57 (lexpr)



state 110

    expr  ->  expr . PLUS expr   (rule 28)
    expr  ->  expr . MINUS expr   (rule 29)
    expr  ->  expr . MUL expr   (rule 30)
    expr  ->  expr . DIV expr   (rule 31)
    expr  ->  expr . MOD expr   (rule 32)
    lexpr  ->  expr RELOP expr .   (rule 53)

    PLUS	shift, and go to state 64
    MINUS	shift, and go to state 65
    MUL 	shift, and go to state 66
    DIV 	shift, and go to state 67
    MOD 	shift, and go to state 68

    $default	reduce using rule 53 (lexpr)



state 111

    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr LOR lexpr .   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)

    LAND	shift, and go to state 87

    $default	reduce using rule 54 (lexpr)



state 112

    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)
    lexpr  ->  lexpr LAND lexpr .   (rule 55)


    $default	reduce using rule 55 (lexpr)



state 113

    expr  ->  NAME LBR expr RBR .   (rule 35)

    $default	reduce using rule 35 (expr)



state 114

    def  ->  NAME LBR expr RBR .   (rule 15)

    $default	reduce using rule 15 (def)



state 115

    stms  ->  stms . stm   (rule 4)
    else  ->  ELSE stms .   (rule 50)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    ENDIF	reduce using rule 50 (else)

    stm 	go to state 46
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 116

    if  ->  ifh stms @1 else ENDIF .   (rule 42)

    $default	reduce using rule 42 (if)



state 117

    elseifh  ->  ELSEIF LPAR . lexpr RPAR   (rule 52)

    NAME	shift, and go to state 35
    INT_CONST	shift, and go to state 36
    DOUBLE_CONST	shift, and go to state 37
    STRING_CONST	shift, and go to state 38
    LPAR	shift, and go to state 54
    LNOT	shift, and go to state 55
    MINUS	shift, and go to state 40

    expr	go to state 56
    lexpr	go to state 122



state 118

    if  ->  ifh stms @2 elseifs ENDIF .   (rule 44)

    $default	reduce using rule 44 (if)



state 119

    elseifs  ->  elseiflist else .   (rule 47)

    $default	reduce using rule 47 (elseifs)



state 120

    elseiflist  ->  elseiflist elseif .   (rule 49)

    $default	reduce using rule 49 (elseiflist)



state 121

    stms  ->  stms . stm   (rule 4)
    elseif  ->  elseifh stms .   (rule 51)

    error	shift, and go to state 1
    NAME	shift, and go to state 2
    WHILE	shift, and go to state 3
    IF  	shift, and go to state 4
    TYPE	shift, and go to state 5
    BREAK	shift, and go to state 6
    CONTINUE	shift, and go to state 7
    INPUT	shift, and go to state 8
    OUTPUT	shift, and go to state 9
    OUTPUTLN	shift, and go to state 10

    ENDIF	reduce using rule 51 (elseif)
    ELSE	reduce using rule 51 (elseif)
    ELSEIF	reduce using rule 51 (elseif)

    stm 	go to state 46
    decl	go to state 13
    type	go to state 14
    oper	go to state 15
    assign	go to state 16
    lval	go to state 17
    lval_name	go to state 18
    if  	go to state 19
    ifh 	go to state 20
    while	go to state 21
    whileh	go to state 22
    input	go to state 23
    output	go to state 24
    outputln	go to state 25



state 122

    elseifh  ->  ELSEIF LPAR lexpr . RPAR   (rule 52)
    lexpr  ->  lexpr . LOR lexpr   (rule 54)
    lexpr  ->  lexpr . LAND lexpr   (rule 55)

    RPAR	shift, and go to state 123
    LOR 	shift, and go to state 86
    LAND	shift, and go to state 87



state 123

    elseifh  ->  ELSEIF LPAR lexpr RPAR .   (rule 52)

    $default	reduce using rule 52 (elseifh)



state 124

    $   	go to state 125



state 125

    $   	go to state 126



state 126

    $default	accept
